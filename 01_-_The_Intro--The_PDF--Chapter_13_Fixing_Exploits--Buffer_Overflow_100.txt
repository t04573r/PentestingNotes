#### Buffer Overflow




				A buffer is a memory area intended to hold content that is often sent by the user
				for later processing. Some buffers have a dynamic size while others have a fixed preallocated size.
				
				Buffer overflows have been sued since the late 1980s and are still relevant today.
				When the user's provided content goes beyond the stack limit and overruns into an adjacent memory areaand causes nexpected behaviour.
				Memory corruption vulnerabilities can occur in different parts of a program such as the heap or the stack.
				The heap is dyunamilcally nnaged and typically stores large chunks of globally accessible data.
				The stack stores local function data and the size is geerally fixed.
				The stack contains local variables like integers or buffers.
				
				*buffer[64]*
	strcpy(buffer, argv[1]);
	
	A buffer is declared and a string is copied to it. 
	
		If the user overflows the buffer space, it culd overwrite the return addresss.
		Rewriting the return address executes the ret function inside the EIP/RIP, the instruction pointer responsible for keeping track of current instruction. 
		
	If an attacker has control over the return address, they may eventually control the program flow as well. 
	
	Executable Space Protection ,esp, is one mitigation.
	
	Here's a breakdown of the attack:
	
    Create a large buffer to trigger the overflow.
    Take control of EIP by overwriting a return address on the stack, padding the large buffer with an appropriate offset.
    Include a chosen payload in the buffer prepended by an optional NOP5 sled.
    Choose a correct return address instruction such as JMP ESP (or a different register) to redirect the execution flow to the payload.

	To determine the correct return address, a clone of the virtual target can be made and viewed using a debugger.
	Reverse engineering the payload can be difficult but will reveal how it functions. For now, we will focus only on shellcode replacement.
	

